package main

import (
	"encoding/json"
	"net"
	"net/http"
	"os"
	"sync"
)

type Domain struct {
	Ipv4      net.IP `json:"ipv4"`
	IsService bool   `json:"isService"`
}

var (
	domainUrl string
)

func main() {
	domainUrl = os.Args[1]

	var domainMap map[string]Domain
	var mu sync.Mutex

	var subdomainChan chan string
	var subdomainWg sync.WaitGroup

	subdomainWg.Add(2)
	go getAssetFinderSubdomainList(subdomainChan, &subdomainWg)
	go getSubFinderSubdomainList(subdomainChan, &subdomainWg)
	go func() {
		subdomainWg.Wait()
		close(subdomainChan)
	}()

	var wg sync.WaitGroup
	for subdomain := range subdomainChan {
		println(subdomain)
		wg.Add(1)
		go func() {
			domain := domainMap[subdomain]
			defer func() {
				mu.Lock()
				domainMap[subdomain] = domain
				mu.Unlock()
				wg.Done()
			}()

			if domain.IsService {
				return
			}

			ipv4, err := getIpFromDomain(subdomain)
			if err != nil {
				println(err.Error())
				return
			}
			domain.Ipv4 = ipv4

			res, err := http.Get("https://" + subdomain)
			if err != nil {
				println(err.Error())
				domain.IsService = false
				return
			}
			if res.StatusCode < 200 || res.StatusCode >= 400 {
				domain.IsService = false
				return
			}
			domain.IsService = true
		}()
	}
	wg.Wait()

	result, err := json.Marshal(domainMap)
	if err != nil {
		println(err.Error())
		return
	}

	file, err := os.Create("./output.json")
	if err != nil {
		println(err.Error())
		return
	}
	defer file.Close()

	if _, err := file.Write(result); err != nil {
		println(err.Error())
		return
	}
}
