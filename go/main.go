package main

import (
	"encoding/json"
	"errors"
	"net"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"sync"
)

func getAssetFinderSubdomainList(domainUrl string, subdomainChan chan string, wg *sync.WaitGroup) {
	defer wg.Done()

	cmd := exec.Command("assetfinder", "-subs-only", domainUrl)
	stdout, err := cmd.Output()

	if err != nil {
		println(err.Error())
		return
	}

	lines := strings.Split((string(stdout)), "\n")

	for _, line := range lines {
		println("assetfinder found " + line)
		subdomainChan <- line
	}
}

func getSubFinderSubdomainList(domainUrl string, subdomainChan chan string, wg *sync.WaitGroup) {
	defer wg.Done()

	cmd := exec.Command("subfinder", "-d", domainUrl)
	stdout, err := cmd.Output()
	if err != nil {
		println(err.Error())
		return
	}

	lines := strings.Split((string(stdout)), "\n")
	for _, line := range lines {
		println("subfinder found " + line)
		subdomainChan <- line
	}
}

func getIpFromDomain(domain string) (net.IP, error) {
	ips, _ := net.LookupIP(domain)
	for _, ip := range ips {
		if ipv4 := ip.To4(); ipv4 != nil {
			return ipv4, nil
		}
	}
	return nil, errors.New(domain + "ip not found")
}

type Domain struct {
	Ipv4      net.IP `json:"ipv4"`
	IsService bool   `json:"isService"`
}

func main() {
	domainUrl := os.Args[1]
	subdomainChan := make(chan string, 500)
	domainMap := make(map[string]Domain)

	wg := &sync.WaitGroup{}

	wg.Add(2)
	go getAssetFinderSubdomainList(domainUrl, subdomainChan, wg)
	go getSubFinderSubdomainList(domainUrl, subdomainChan, wg)
	wg.Wait()
	close(subdomainChan)

	for subdomain := range subdomainChan {
		wg.Add(1)
		go func() {
			defer wg.Done()

			domain := domainMap[subdomain]
			defer func() {
				domainMap[subdomain] = domain
			}()

			if domain.IsService {
				return
			}

			ipv4, err := getIpFromDomain(subdomain)
			if err != nil {
				println(err.Error())
				return
			}
			domain.Ipv4 = ipv4

			res, err := http.Get("https://" + subdomain)
			if err != nil {
				println(err.Error())
				domain.IsService = false
				return
			}
			if res.StatusCode < 200 || res.StatusCode >= 400 {
				domain.IsService = false
				return
			}
			domain.IsService = true
		}()
	}

	wg.Wait()

	result, err := json.Marshal(domainMap)
	if err != nil {
		println(err.Error())
		return
	}

	file, err := os.Create("./output.json")
	if err != nil {
		println(err.Error())
		return
	}

	_, err = file.Write(result)
	if err != nil {
		println(err.Error())
		return
	}
}
